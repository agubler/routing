(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", '../Promise'], factory);
    }
})(function (require, exports) {
    "use strict";
    var Promise_1 = require('../Promise');
    /*
    Based on sizeof.js by Stephen Morley
    
    A function to calculate the approximate memory usage of objects
    
    Created by Stephen Morley - http://code.stephenmorley.org/ - and released under
    the terms of the CC0 1.0 Universal legal code:
    
    http://creativecommons.org/publicdomain/zero/1.0/legalcode
    
    Returns the approximate memory usage, in bytes, of the specified object.
    */
    function getApproximateByteSize(object) {
        var objects = [object];
        var size = 0;
        for (var index = 0; index < objects.length; index++) {
            switch (typeof objects[index]) {
                case 'boolean':
                    size += 4;
                    break;
                case 'number':
                    size += 8;
                    break;
                case 'string':
                    size += 2 * objects[index].length;
                    break;
                case 'object':
                    // if the object is not an array, add the sizes of the keys
                    if (Object.prototype.toString.call(objects[index]) !== '[object Array]') {
                        for (var key in objects[index]) {
                            size += 2 * key.length;
                        }
                    }
                    // loop over the keys
                    for (var key in objects[index]) {
                        // determine whether the value has already been processed
                        var processed = false;
                        for (var j = 0; j < objects.length; j++) {
                            if (objects[j] === objects[index][key]) {
                                processed = true;
                                break;
                            }
                        }
                        // queue the value to be processed if appropriate
                        if (!processed) {
                            objects.push(objects[index][key]);
                        }
                    }
            }
        }
        return size;
    }
    exports.getApproximateByteSize = getApproximateByteSize;
    /**
     * Calls the method or returns undefined.
     */
    function invokeOrNoop(O, P, args) {
        if (args === void 0) { args = []; }
        var method = O[P];
        return method ? method.apply(O, args) : undefined;
    }
    exports.invokeOrNoop = invokeOrNoop;
    function normalizeStrategy(_a) {
        var size = _a.size, _b = _a.highWaterMark, highWaterMark = _b === void 0 ? 1 : _b;
        return {
            size: size,
            highWaterMark: highWaterMark > 0 ? highWaterMark : 1
        };
    }
    exports.normalizeStrategy = normalizeStrategy;
    function promiseInvokeOrFallbackOrNoop(object, method1, args1, method2, args2) {
        if (args2 === void 0) { args2 = []; }
        var method;
        try {
            method = object[method1];
        }
        catch (error) {
            return Promise_1.default.reject(error);
        }
        if (!method) {
            return promiseInvokeOrNoop(object, method2, args2);
        }
        if (!args1) {
            args1 = [];
        }
        try {
            return Promise_1.default.resolve(method.apply(object, args1));
        }
        catch (error) {
            return Promise_1.default.reject(error);
        }
    }
    exports.promiseInvokeOrFallbackOrNoop = promiseInvokeOrFallbackOrNoop;
    /**
     * Returns a promise that resolves the with result of the method call or undefined.
     */
    function promiseInvokeOrNoop(O, P, args) {
        if (args === void 0) { args = []; }
        var method;
        try {
            method = O[P];
        }
        catch (error) {
            return Promise_1.default.reject(error);
        }
        if (!method) {
            return Promise_1.default.resolve();
        }
        try {
            return Promise_1.default.resolve(method.apply(O, args));
        }
        catch (error) {
            return Promise_1.default.reject(error);
        }
    }
    exports.promiseInvokeOrNoop = promiseInvokeOrNoop;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdHJlYW1zL3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0lBQ0Esd0JBQW9CLFlBQVksQ0FBQyxDQUFBO0lBRWpDOzs7Ozs7Ozs7OztNQVdFO0lBQ0YsZ0NBQXVDLE1BQVc7UUFDakQsSUFBSSxPQUFPLEdBQUcsQ0FBRSxNQUFNLENBQUUsQ0FBQztRQUN6QixJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7UUFFYixHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQztZQUNyRCxNQUFNLENBQUMsQ0FBQyxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQy9CLEtBQUssU0FBUztvQkFDYixJQUFJLElBQUksQ0FBQyxDQUFDO29CQUNWLEtBQUssQ0FBQztnQkFFUCxLQUFLLFFBQVE7b0JBQ1osSUFBSSxJQUFJLENBQUMsQ0FBQztvQkFDVixLQUFLLENBQUM7Z0JBRVAsS0FBSyxRQUFRO29CQUNaLElBQUksSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQztvQkFDbEMsS0FBSyxDQUFDO2dCQUVQLEtBQUssUUFBUTtvQkFDWiwyREFBMkQ7b0JBQzNELEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7d0JBQ3pFLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7NEJBQ2hDLElBQUksSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQzt3QkFDeEIsQ0FBQztvQkFD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Q0FBTSxFQUFFLENBQVMsRUFBRSxJQUFnQjtRQUFoQixvQkFBZ0IsR0FBaEIsU0FBZ0I7UUFDdEUsSUFBSSxNQUFXLENBQUM7UUFFaEIsSUFBSSxDQUFDO1lBQ0osTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNmLENBQ0E7UUFBQSxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ2QsTUFBTSxDQUFDLGlCQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlCLENBQUM7UUFFRCxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDYixNQUFNLENBQUMsaUJBQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMxQixDQUFDO1FBRUQsSUFBSSxDQUFDO1lBQ0osTUFBTSxDQUFDLGlCQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDL0MsQ0FDQTtRQUFBLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7WUFDZCxNQUFNLENBQUMsaUJBQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUIsQ0FBQztJQUNGLENBQUM7SUFwQmUsMkJBQW1CLHNCQW9CbEMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN0cmF0ZWd5IH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uL1Byb21pc2UnO1xuXG4vKlxuQmFzZWQgb24gc2l6ZW9mLmpzIGJ5IFN0ZXBoZW4gTW9ybGV5XG5cbkEgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBhcHByb3hpbWF0ZSBtZW1vcnkgdXNhZ2Ugb2Ygb2JqZWN0c1xuXG5DcmVhdGVkIGJ5IFN0ZXBoZW4gTW9ybGV5IC0gaHR0cDovL2NvZGUuc3RlcGhlbm1vcmxleS5vcmcvIC0gYW5kIHJlbGVhc2VkIHVuZGVyXG50aGUgdGVybXMgb2YgdGhlIENDMCAxLjAgVW5pdmVyc2FsIGxlZ2FsIGNvZGU6XG5cbmh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL3B1YmxpY2RvbWFpbi96ZXJvLzEuMC9sZWdhbGNvZGVcblxuUmV0dXJucyB0aGUgYXBwcm94aW1hdGUgbWVtb3J5IHVzYWdlLCBpbiBieXRlcywgb2YgdGhlIHNwZWNpZmllZCBvYmplY3QuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFwcHJveGltYXRlQnl0ZVNpemUob2JqZWN0OiBhbnkpOiBudW1iZXIge1xuXHRsZXQgb2JqZWN0cyA9IFsgb2JqZWN0IF07XG5cdGxldCBzaXplID0gMDtcblxuXHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgb2JqZWN0cy5sZW5ndGg7IGluZGV4KyspIHtcblx0XHRzd2l0Y2ggKHR5cGVvZiBvYmplY3RzW2luZGV4XSkge1xuXHRcdFx0Y2FzZSAnYm9vbGVhbic6XG5cdFx0XHRcdHNpemUgKz0gNDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRcdHNpemUgKz0gODtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ3N0cmluZyc6XG5cdFx0XHRcdHNpemUgKz0gMiAqIG9iamVjdHNbaW5kZXhdLmxlbmd0aDtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgJ29iamVjdCc6XG5cdFx0XHRcdC8vIGlmIHRoZSBvYmplY3QgaXMgbm90IGFuIGFycmF5LCBhZGQgdGhlIHNpemVzIG9mIHRoZSBrZXlzXG5cdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0c1tpbmRleF0pICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQga2V5IGluIG9iamVjdHNbaW5kZXhdKSB7XG5cdFx0XHRcdFx0XHRzaXplICs9IDIgKiBrZXkubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGxvb3Agb3ZlciB0aGUga2V5c1xuXHRcdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0c1tpbmRleF0pIHtcblx0XHRcdFx0XHQvLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgdmFsdWUgaGFzIGFscmVhZHkgYmVlbiBwcm9jZXNzZWRcblx0XHRcdFx0XHRsZXQgcHJvY2Vzc2VkID0gZmFsc2U7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG9iamVjdHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdGlmIChvYmplY3RzW2pdID09PSBvYmplY3RzW2luZGV4XVtrZXldKSB7XG5cdFx0XHRcdFx0XHRcdHByb2Nlc3NlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHF1ZXVlIHRoZSB2YWx1ZSB0byBiZSBwcm9jZXNzZWQgaWYgYXBwcm9wcmlhdGVcblx0XHRcdFx0XHRpZiAoIXByb2Nlc3NlZCkge1xuXHRcdFx0XHRcdFx0b2JqZWN0cy5wdXNoKG9iamVjdHNbaW5kZXhdW2tleV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzaXplO1xufVxuXG4vKipcbiAqIENhbGxzIHRoZSBtZXRob2Qgb3IgcmV0dXJucyB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZva2VPck5vb3AoTzogYW55LCBQOiBzdHJpbmcsIGFyZ3M6IGFueVtdID0gW10pOiBhbnkge1xuXHRjb25zdCBtZXRob2Q6IEZ1bmN0aW9uID0gT1tQXTtcblx0cmV0dXJuIG1ldGhvZCA/IG1ldGhvZC5hcHBseShPLCBhcmdzKSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVN0cmF0ZWd5PFQ+KHsgc2l6ZSwgaGlnaFdhdGVyTWFyayA9IDEgfTogU3RyYXRlZ3k8VD4pOiBTdHJhdGVneTxUPiB7XG5cdHJldHVybiA8U3RyYXRlZ3kgPFQ+PiB7XG5cdFx0c2l6ZTogc2l6ZSxcblx0XHRoaWdoV2F0ZXJNYXJrOiBoaWdoV2F0ZXJNYXJrID4gMCA/IGhpZ2hXYXRlck1hcmsgOiAxXG5cdH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlSW52b2tlT3JGYWxsYmFja09yTm9vcChvYmplY3Q6IGFueSwgbWV0aG9kMTogc3RyaW5nLCBhcmdzMTogYW55W10sIG1ldGhvZDI6IHN0cmluZywgYXJnczI6IGFueVtdID0gW10pOiBQcm9taXNlPGFueT4ge1xuXHRsZXQgbWV0aG9kOiBGdW5jdGlvbjtcblxuXHR0cnkge1xuXHRcdG1ldGhvZCA9IG9iamVjdFttZXRob2QxXTtcblx0fVxuXHRjYXRjaCAoZXJyb3IgKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcblx0fVxuXG5cdGlmICghbWV0aG9kKSB7XG5cdFx0cmV0dXJuIHByb21pc2VJbnZva2VPck5vb3Aob2JqZWN0LCBtZXRob2QyLCBhcmdzMik7XG5cdH1cblxuXHRpZiAoIWFyZ3MxKSB7XG5cdFx0YXJnczEgPSBbXTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShtZXRob2QuYXBwbHkob2JqZWN0LCBhcmdzMSkpO1xuXHR9XG5cdGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG5cdH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRoZSB3aXRoIHJlc3VsdCBvZiB0aGUgbWV0aG9kIGNhbGwgb3IgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZUludm9rZU9yTm9vcChPOiBhbnksIFA6IHN0cmluZywgYXJnczogYW55W10gPSBbXSk6IFByb21pc2U8YW55PiB7XG5cdGxldCBtZXRob2Q6IGFueTtcblxuXHR0cnkge1xuXHRcdG1ldGhvZCA9IE9bUF07XG5cdH1cblx0Y2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcblx0fVxuXG5cdGlmICghbWV0aG9kKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ldGhvZC5hcHBseShPLCBhcmdzKSk7XG5cdH1cblx0Y2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcblx0fVxufVxuIl19