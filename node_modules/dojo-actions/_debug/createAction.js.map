{"version":3,"file":"createAction.js","sourceRoot":"","sources":["createAction.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * The actions module for Dojo 2\n * @module dojo-actions/actions\n */\nimport compose, { ComposeFactory } from 'dojo-compose/compose';\nimport Map from 'dojo-core/Map';\nimport Promise, { Thenable, isThenable } from 'dojo-core/Promise';\nimport WeakMap from 'dojo-core/WeakMap';\nimport { assign } from 'dojo-core/lang';\n\nexport type ActionLabel = string | symbol;\n\n/* Cannot use an indexer, because indexers can only be string | number */\nconst actionMap = new Map<ActionLabel, Action<any, any, any>>();\n\ninterface ActionMethods<T, O> {\n\tdo: (options?: O) => T | Promise<T>;\n\tundo: () => T | Promise<T>;\n\tredo: (options?: O) => T | Promise<T>;\n\tenabler: (enabled: boolean) => boolean | Promise<boolean>;\n}\n\nconst actionMethods = new WeakMap<Action<any, ActionOptions<any>, any>, ActionMethods<any, any>>();\n\nexport interface ActionPromise<T, O extends ActionOptions<any>> extends Promise<T> {\n\t/**\n\t * Performs an undo of the action. Returns another ActionPromise.  If the action\n\t * does not handle //\n\t */\n\tundo(): ActionPromise<T, O>;\n\tredo(options?: O): ActionPromise<T, O>;\n}\n\n/**\n * Options that are passed to an action.do or action.redo method\n * @template T The type of the target for the action\n */\nexport interface ActionOptions<T> {\n\t/**\n\t * The target of the action\n\t */\n\ttarget?: T;\n}\n\n/**\n * Type base interface for the state of an action, intended to be extended\n */\nexport interface ActionState {\n\t[name: string]: any;\n}\n\n/* TODO: In typescript 1.8 <T, O extends ActionOptions<T>> will be valid */\n\n/**\n * An action encapsulates do, undo and redo functionality\n * @template T The type that the action's promise will resolve to\n * @template O (extends ActionOptions) the type of the options to be passed the do or redo function\n * @template S (extends ActionState) the type of state for the action\n */\nexport interface Action<T, O extends ActionOptions<T>, S extends ActionState> {\n\t/**\n\t * The action type\n\t */\n\ttype: ActionLabel;\n\n\t/**\n\t * Invoke the action\n\t * @param   options Optional argument providing any options to the action\n\t * @returns         a Promise which is also decorated with redo and undo methods\n\t */\n\tdo(options?: O): ActionPromise<T, O>;\n\n\t/**\n\t * Determine if the action is currently enabled.\n\t */\n\tenabled: boolean;\n\n\t/**\n\t * A hash that contains any state for the action to facilitate items like \"undo\"\n\t */\n\tstate?: S;\n\n\t/**\n\t * Disable the action\n\t * @returns A promise the resolves when the action is disabled\n\t */\n\tdisable(): Promise<boolean>;\n\n\t/**\n\t * Enable the promise\n\t * @returns A promise that resolves when the action is enabled\n\t */\n\tenable(): Promise<boolean>;\n\n\t/**\n\t * Destory the action\n\t * @returns A promise that resolves when the action is destoryed\n\t */\n\tdestroy(): Promise<boolean>;\n}\n\n/**\n * Options that are passed when creating a new action\n * @template T The type that the action's promise will resolve to\n * @template O (extends ActionOptions) the type of the options to be passed the do or redo function\n * @template S (extends ActionState) the type of state for the action\n */\nexport interface ActionFactoryOptions<T, O extends ActionOptions<any>, S extends ActionState> {\n\ttype: ActionLabel;\n\tdo: (options?: O) => T | Promise<T>;\n\tstate?: S;\n\tundo?: () => T | Promise<T>;\n\tredo?: (options?: O) => T | Promise<T>;\n\tenabler?: (enabled: boolean) => boolean | Promise<boolean>;\n}\n\n/**\n * A factory that creates a new action\n */\nexport interface ActionFactory extends ComposeFactory<Action<any, any, any>, ActionFactoryOptions<any, any, any>> {\n\t/**\n\t * A factory that creates a new action\n\t * @param   options The options to specify the action.\n\t * @returns         The action instance\n\t * @template T The type that the action's promise will resolve to\n\t * @template O (extends ActionOptions) the type of the options to be passed the do or redo function\n\t * @template S (extends ActionState) the type of state for the action\n\t */\n\t<T, O extends ActionOptions<T>, S extends ActionState>(options: ActionFactoryOptions<T, O, S>): Action<T, O, S>;\n\n\tdisable<T, O extends ActionOptions<T>, S extends ActionState>(action: ActionLabel | Action<T, O, S>): Promise<boolean>;\n\tenable<T, O extends ActionOptions<T>, S extends ActionState>(action: ActionLabel | Action<T, O, S>): Promise<boolean>;\n\n\tdestroy<T, O extends ActionOptions<T>, S extends ActionState>(action: ActionLabel | Action<T, O, S>): Promise<boolean>;\n}\n\n/**\n * Decorate a Thenable/Promise to be an ActionPromise\n * @param    p The target to decorate\n * @returns    The decorated ActionPromise\n * @template T The return type of the action\n * @template O (extends ActionOptions) The options for the action\n */\nfunction decoratePromise<T, O>(p: Thenable<T> | Promise<T>, action: Action<T, O, ActionState>): ActionPromise<T, O> {\n\tconst result = p as ActionPromise<T, O>;\n\tresult.undo = function undo() {\n\t\treturn decoratePromise(p.then(() => undoFn.call(action)), action);\n\t};\n\tresult.redo = function redo(options) {\n\t\treturn decoratePromise(p.then(() => redoFn.call(action, options)), action);\n\t};\n\treturn result;\n}\n\nfunction undoFn<T>(): Thenable<T> {\n\tconst action: Action<T, ActionOptions<T>, ActionState> = this;\n\tconst _undo = actionMethods.get(action).undo;\n\t/* if undo is not defined, we will resolve with undefined */\n\tif (!_undo) {\n\t\treturn new Promise((resolve) => { resolve(); });\n\t}\n\tif (!action.enabled) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\treject(new Error(`Action \"${action.type}\" not enabled`));\n\t\t});\n\t}\n\ttry {\n\t\tconst result: T | Thenable<T> = _undo.call(action);\n\t\treturn isThenable(result) ? result : new Promise((resolve) => {\n\t\t\tresolve(result);\n\t\t});\n\t}\n\tcatch (e) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\treject(e);\n\t\t});\n\t}\n}\n\nfunction redoFn<T, O extends ActionOptions<T>>(options?: O): Thenable<T> {\n\tconst action: Action<T, O, ActionState> = this;\n\t/* If redo is undefined, we will automatically substitute do */\n\tconst _redo = actionMethods.get(action).redo || actionMethods.get(action).do;\n\tif (!action.enabled) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\treject(new Error(`Action \"${String(action.type)}\" not enabled`));\n\t\t});\n\t}\n\ttry {\n\t\tconst result: T | Thenable<T> = _redo.call(action, options);\n\t\treturn isThenable(result) ? result : new Promise((resolve) => {\n\t\t\tresolve(result);\n\t\t});\n\t}\n\tcatch (e) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\treject(e);\n\t\t});\n\t}\n}\n\nfunction doFn<T, O extends ActionOptions<T>>(options: O): ActionPromise<T, O> {\n\tconst action: Action<T, O, ActionState> = this;\n\tif (!action.enabled) {\n\t\treturn decoratePromise(new Promise((resolve, reject) => {\n\t\t\treject(new Error(`Action \"${String(action.type)}\" not enabled`));\n\t\t}), action);\n\t}\n\ttry {\n\t\tconst _do = actionMethods.get(action).do;\n\t\tconst result: T | Thenable<T> = _do.call(action, options);\n\t\treturn decoratePromise(isThenable(result) ? result : new Promise((resolve) => {\n\t\t\tresolve(result);\n\t\t}), action);\n\t}\n\tcatch (e) {\n\t\treturn decoratePromise(new Promise((resolve, reject) => {\n\t\t\treject(e);\n\t\t}), action);\n\t}\n}\n\n/**\n * A factory that creates a new action\n */\nconst createAction = compose({\n\tdo: doFn,\n\tenabled: false,\n\tdisable() {\n\t\treturn new Promise((resolve) => {\n\t\t\tresolve(this.enabled = false);\n\t\t});\n\t},\n\tenable() {\n\t\treturn new Promise((resolve) => {\n\t\t\tresolve(this.enabled = true);\n\t\t});\n\t},\n\tdestroy() {\n\t\treturn new Promise((resolve) => {\n\t\t\tactionMap.delete(this.type);\n\t\t\tObject.defineProperty(this, 'type', {\n\t\t\t\tvalue: undefined\n\t\t\t});\n\t\t\tactionMethods.delete(this);\n\t\t\tdelete this.state;\n\t\t\tthis.enabled = false;\n\t\t\tresolve(false);\n\t\t});\n\t}\n}, function(instance: Action<any, any, any>, options: ActionFactoryOptions<any, any, any>) {\n\n\tif (!options.type) {\n\t\tthrow new TypeError('Missing action type, cannot create action.');\n\t}\n\n\tif (!options.do) {\n\t\tthrow new TypeError('Missing action method \"do\", cannot create action.');\n\t}\n\n\tif (actionMap.has(options.type)) {\n\t\tthrow new TypeError(`Duplicate action type of \"${String(options.type)}\"`);\n\t}\n\n\tactionMethods.set(instance, {\n\t\tdo: options.do,\n\t\tundo: options.undo,\n\t\tredo: options.redo,\n\t\tenabler: options.enabler\n\t});\n\n\t/* Makes the property read only, because we don't want\n\t   accidental reassignment */\n\tObject.defineProperty(instance, 'type', {\n\t\tvalue: options.type,\n\t\twritable: false,\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t});\n\n\tinstance.state = {};\n\tif (options.state) {\n\t\tassign(instance.state, options.state);\n\t}\n\n\tinstance.enabled = true;\n\n\tactionMap.set(instance.type, instance);\n}) as ActionFactory;\n\n/**\n * Returns an action based on the supplied label\n * @param    type The type of action to be retrieved\n * @returns       The action (or undefined)\n * @template T    The type that the action's promise will resolve to\n * @template O    (extends ActionOptions) the type of the options to be passed the do or redo function\n * @template S    (extends ActionState) the type of state for the action\n */\nexport function byType<T, O extends ActionOptions<any>, S extends ActionState>(type: ActionLabel): Action<T, O, S> {\n\treturn actionMap.get(type);\n};\n\n/**\n * Type guard to determine if the value is an Action\n * @param    value The value to be checked\n * @returns        Returns `true` if is an action, otherwise `false`\n */\nexport function isAction(value: any): value is Action<any, any, any> {\n\treturn typeof value === 'object' && 'type' in value && 'do' in value && typeof value.do === 'function';\n}\n\n/**\n * Returns if the current action is enabled or not\n * @param   action The action label or an action instance\n * @returns        Returns true if enabled or false if disabled\n * @template T     The type that the action's promise will resolve to\n * @template O     (extends ActionOptions) the type of the options to be passed the do or redo function\n * @template S     (extends ActionState) the type of state for the action\n */\nexport function isEnabled<T, O extends ActionOptions<any>, S extends ActionState>(action: ActionLabel | Action<T, O, S>): boolean {\n\treturn isAction(action) ? action.enabled : actionMap.has(action) && actionMap.get(action).enabled;\n};\n\nexport default createAction;\n"]}