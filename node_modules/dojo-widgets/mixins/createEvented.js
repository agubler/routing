(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", 'dojo-actions/createAction', 'dojo-core/aspect', 'dojo-core/WeakMap', 'dojo-compose/compose', './createDestroyable'], factory);
    }
})(function (require, exports) {
    "use strict";
    var createAction_1 = require('dojo-actions/createAction');
    var aspect_1 = require('dojo-core/aspect');
    var WeakMap_1 = require('dojo-core/WeakMap');
    var compose_1 = require('dojo-compose/compose');
    var createDestroyable_1 = require('./createDestroyable');
    /* TODO: consider a has flag for dojo-actions so it isn't a hard dependency */
    /**
     * A map of hashes of listeners for event types
     */
    var listenersMap = new WeakMap_1.default();
    /**
     * An Actionable callback type guard
     * @param value The value to guard against
     */
    function isActionable(value) {
        return typeof value === 'object' && 'do' in value && typeof value.do === 'function';
    }
    function resolveEventListener(listener) {
        var action;
        if (isActionable(listener)) {
            action = listener;
        }
        if (typeof listener === 'string') {
            action = createAction_1.byType(listener);
            if (!action) {
                throw new Error("Cannot resolve action type \"" + listener + "\"");
            }
        }
        return action ? function (event) {
            action.do({ event: event });
        } : listener;
    }
    exports.resolveEventListener = resolveEventListener;
    var createEvented = compose_1.default({
        emit: function (event) {
            var method = listenersMap.get(this)[event.type];
            if (method) {
                method.call(this, event);
            }
        },
        on: function (type, listener) {
            return aspect_1.on(listenersMap.get(this), type, resolveEventListener(listener));
        }
    })
        .mixin({
        mixin: createDestroyable_1.default,
        initialize: function (instance, options) {
            /* Initialize the listener map */
            listenersMap.set(instance, {});
            if (options && 'listeners' in options) {
                for (var eventType in options.listeners) {
                    instance.own(instance.on(eventType, resolveEventListener(options.listeners[eventType])));
                }
            }
        }
    });
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = createEvented;
});
//# sourceMappingURL=../_debug/mixins/createEvented.js.map