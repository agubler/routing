{"version":3,"file":"createMemoryStore.js","sourceRoot":"","sources":["createMemoryStore.ts"],"names":[],"mappings":"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","sourcesContent":["import { OrderedMap, Map } from 'immutable/immutable';\nimport { Observable, Observer } from 'rxjs/Rx';\nimport { assign } from 'dojo-core/lang';\nimport Promise, { isThenable } from 'dojo-core/Promise';\nimport WeakMap from 'dojo-core/WeakMap';\nimport compose, { ComposeFactory } from 'dojo-compose/compose';\n\nexport type StoreIndex = number | string;\n\nexport interface MemoryStorePragma {\n\t/**\n\t * The identity of the object\n\t */\n\tid?: StoreIndex;\n\n\t/**\n\t * Should the item be replaced if already exists.\n\t */\n\treplace?: boolean;\n}\n\nexport interface MemoryStorePromise<T> extends Promise<T>, MemoryStore<T> { }\n\nexport interface MemoryStoreOptions<T extends Object> {\n\t/**\n\t * Any initial data that should populate the store\n\t */\n\tdata?: T[];\n\n\t/**\n\t * The property of each object to use as the identity for the object\n\t */\n\tidProperty?: StoreIndex;\n}\n\nexport interface MemoryStore<T extends Object> {\n\t/**\n\t * The property that determines the ID of the object (defaults to `id`)\n\t */\n\tidProperty: StoreIndex;\n\n\t/**\n\t * Retrieve an object from the store based on the object's ID\n\t * @param id The ID of the object to retrieve\n\t */\n\tget(id: StoreIndex): MemoryStorePromise<T>;\n\n\t/**\n\t * Observe an object, any subsequent changes to the object can also be observed via the observable\n\t * interface that is returned.  If the object is not present in the store, the observation will be\n\t * immediatly completed.  If the object is deleted from the store, the observation will be completed\n\t * @param id The ID of the object to observe\n\t */\n\tobserve(id: StoreIndex): Observable<T>;\n\n\t/**\n\t * Put an item in the object store.\n\t * @param item The item to put\n\t * @param options The pragma to use when putting the object\n\t */\n\tput(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Add an item to the object store.\n\t * @param add The item to add\n\t * @param options The pragma to use when adding the object\n\t */\n\tadd(item: T, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Patch an object in the store by providing a partial object.  The result will be a promise\n\t * that resolves with the patched object.\n\t * @param partial The partial object to patch the existing object with\n\t * @param options The pragma to use when patching the object\n\t */\n\tpatch(partial: any, options?: MemoryStorePragma): MemoryStorePromise<T>;\n\n\t/**\n\t * Remove an object from the store.\n\t * @param id The ID of the object to remove\n\t * @param item The object to remove\n\t */\n\tdelete(id: StoreIndex): MemoryStorePromise<boolean>;\n\tdelete(item: T): MemoryStorePromise<boolean>;\n\n\t/**\n\t * Set the stores objects to an array\n\t */\n\tfromArray(items: T[]): MemoryStorePromise<void>;\n}\n\n/**\n * The weak map that contains the data for the stores\n */\nconst dataWeakMap = new WeakMap<MemoryStore<Object>, OrderedMap<StoreIndex, Object>>();\n\n/**\n * The weak map that contains any observers for the stores\n */\nconst observerWeakMap = new WeakMap<MemoryStore<Object>, Map<StoreIndex, Observer<Object>[]>>();\n\nexport interface MemoryStoreFactory extends ComposeFactory<MemoryStore<Object>, MemoryStoreOptions<Object>> {\n\t<T extends Object>(options?: MemoryStoreOptions<T>): MemoryStore<T>;\n\n\t/**\n\t * Creates a memory store from an array of objects\n\t * @params data The array of data to create the memory store from\n\t */\n\tfromArray<T extends Object>(data: T[]): MemoryStore<T>;\n}\n\n/**\n * The methods to decorate the MemoryStorePromise with\n */\nconst storeMethods = [ 'get', 'put', 'add', 'patch', 'delete', 'fromArray' ];\n\n/**\n * Utility function that takes a result and generates a MemoryStorePromise\n * @param store The store to use as a reference when decorating the Promise\n * @param result The result to wrap, if Thenable, it will be decorated, otherwise a new Promise is created\n */\nfunction wrapResult<R>(store: MemoryStore<Object>, result: R): MemoryStorePromise<R> {\n\t/* TODO: this all seems pretty expensive, there has to be a better way */\n\tconst p = (isThenable(result) ? result : Promise.resolve(result)) as MemoryStorePromise<R>;\n\tstoreMethods.forEach((method) => {\n\t\t(<any> p)[method] = (...args: any[]) => {\n\t\t\treturn p.then(() => {\n\t\t\t\treturn (<any> store)[method].apply(store, args);\n\t\t\t});\n\t\t};\n\t});\n\treturn p;\n}\n\n/**\n * Utility function that takes an error and generates a rejected MemoryStorePromise\n * @param store The store to use as a reference when decorating the Promise\n * @param result The result to wrap\n */\nfunction wrapError(store: MemoryStore<Object>, result: Error): MemoryStorePromise<Object> {\n\tconst p = (isThenable(result) ? result : Promise.reject(result)) as MemoryStorePromise<Object>;\n\tstoreMethods.forEach((method) => {\n\t\t(<any> p)[method] = (...args: any[]) => {\n\t\t\treturn p.then(() => {\n\t\t\t\treturn (<any> store)[method].apply(store, args);\n\t\t\t});\n\t\t};\n\t});\n\treturn p;\n}\n\n/**\n * Create a new instance of a MemoryStore\n */\nconst createMemoryStore = compose({\n\tidProperty: 'id',\n\n\tget(id: StoreIndex): MemoryStorePromise<Object> {\n\t\tconst store: MemoryStore<Object> = this;\n\t\tconst data = dataWeakMap.get(store);\n\t\treturn wrapResult(store, data && data.get(String(id)));\n\t},\n\n\tobserve(id: StoreIndex): Observable<Object> {\n\t\tconst store: MemoryStore<Object> = this;\n\t\treturn new Observable(function subscribe(observer: Observer<Object>) {\n\t\t\tstore.get(String(id)).then((item: Object) => {\n\t\t\t\tif (item) {\n\t\t\t\t\tobserver.next(item);\n\t\t\t\t\tconst observers = observerWeakMap.get(store);\n\t\t\t\t\tconst observerArray: Observer<Object>[] = observers && observers.has(String(id)) ? observers.get(String(id)) : [];\n\t\t\t\t\tobserverArray.push(observer);\n\t\t\t\t\tobserverWeakMap.set(store, (observers ? observers : Map<StoreIndex, Observer<Object>[]>()).set(String(id), observerArray));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tobserver.error(new Error(`ID \"${id}\" not found in store`));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\tput(item: { [property: string]: number | string; }, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\tconst store: MemoryStore<Object> = this;\n\t\tconst data = dataWeakMap.get(store);\n\t\tconst idProperty = store.idProperty;\n\t\tconst id =  options && 'id' in options ? options.id :\n\t\t\tidProperty in item ? item[idProperty] :\n\t\t\tdata ? data.size : 0;\n\t\tif (options && options.replace === false && data && data.has(String(id))) {\n\t\t\treturn wrapError(store, Error(`Duplicate ID \"${id}\" when pragma \"replace\" is false`));\n\t\t}\n\t\titem[idProperty] = id;\n\t\tdataWeakMap.set(store, (data ? data : OrderedMap<StoreIndex, Object>()).set(String(id), item));\n\n\t\tconst observers = observerWeakMap.get(store);\n\t\tif (observers && observers.has(String(id))) {\n\t\t\tobservers.get(String(id)).forEach((observer) => observer.next(item));\n\t\t}\n\t\treturn wrapResult(store, item);\n\t},\n\n\tadd(item: Object, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\treturn this.put(item, assign(options ? options : {}, { replace: false }));\n\t},\n\n\tpatch(partial: { [property: string]: number | string; }, options?: MemoryStorePragma): MemoryStorePromise<Object> {\n\t\tconst store: MemoryStore<Object> = this;\n\t\tconst idProperty = store.idProperty;\n\t\tconst id = options && 'id' in options ? options.id : partial[idProperty];\n\t\tif (!id) {\n\t\t\treturn wrapError(store, new Error(`Object ID must either be passed in \"partial.${idProperty}\" or \"options.id\"`));\n\t\t}\n\t\treturn wrapResult(store, store.get(id).then((item) => {\n\t\t\tif (item) {\n\t\t\t\toptions = options || {};\n\t\t\t\toptions.id = id;\n\t\t\t\treturn store.put(assign(item, partial), options);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn wrapError(store, new Error(`Object with ID \"${id}\" not found, unable to patch.`));\n\t\t\t}\n\t\t}));\n\t},\n\n\tdelete(item: StoreIndex | { [property: string]: number | string; }): MemoryStorePromise<boolean> {\n\t\tconst store: MemoryStore<Object> = this;\n\n\t\t/**\n\t\t * Complete any observers associated with this items id\n\t\t */\n\t\tfunction completeObservable(id: StoreIndex) {\n\t\t\tconst observers = observerWeakMap.get(store);\n\t\t\tif (observers && observers.has(String(id))) {\n\t\t\t\tobservers.get(String(id)).forEach((observer) => observer.complete());\n\t\t\t\tobserverWeakMap.set(store, observers.delete(id));\n\t\t\t}\n\t\t}\n\n\t\tconst idProperty = store.idProperty;\n\t\tconst data = dataWeakMap.get(store);\n\t\tif (typeof item === 'object') {\n\t\t\tif (idProperty in item && data && data.has(String(item[idProperty]))) {\n\t\t\t\tdataWeakMap.set(store, data.delete(String(item[idProperty])));\n\t\t\t\tcompleteObservable(item[idProperty]);\n\t\t\t\treturn wrapResult(store, true);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (data && data.has(String(item))) {\n\t\t\t\tdataWeakMap.set(store, data.delete(String(item)));\n\t\t\t\tcompleteObservable(item);\n\t\t\t\treturn wrapResult(store, true);\n\t\t\t}\n\t\t}\n\t\treturn wrapResult(store, false);\n\t},\n\tfromArray(items: Object[]): MemoryStorePromise<void> {\n\t\tconst store: MemoryStore<Object> = this;\n\t\tconst map: Object = {};\n\t\tconst idProperty = store.idProperty;\n\t\titems.forEach((item: { [prop: string]: StoreIndex }, idx: number) => {\n\t\t\tconst id = idProperty in item ? item[idProperty] : idx;\n\t\t\titem[idProperty] = id;\n\t\t\t(<any> map)[id] = item;\n\t\t});\n\t\tdataWeakMap.set(store, OrderedMap<StoreIndex, Object>(map));\n\t\treturn wrapResult(store, undefined);\n\t}\n}, (instance: MemoryStore<Object>, options: MemoryStoreOptions<Object>) => {\n\tif (options) {\n\t\tif (options.idProperty) {\n\t\t\tinstance.idProperty = options.idProperty;\n\t\t}\n\t\tif (options.data) {\n\t\t\tinstance.fromArray(options.data);\n\t\t}\n\t}\n}).static({\n\tfromArray(data: any[]): MemoryStore<any> {\n\t\treturn createMemoryStore({ data });\n\t}\n}) as MemoryStoreFactory;\n\nexport default createMemoryStore;\n"]}