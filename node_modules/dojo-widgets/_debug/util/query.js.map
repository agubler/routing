{"version":3,"file":"query.js","sourceRoot":"","sources":["query.ts"],"names":[],"mappings":"","sourcesContent":["import { List } from 'immutable/immutable';\nimport { ComposeFactory } from 'dojo-compose/compose';\nimport Promise from 'dojo-core/Promise';\n\ninterface MemoryStore<T> {\n\tget(id: string | number): StorePromise<T>;\n\tadd(item: T): StorePromise<this>;\n\tput(item: T): StorePromise<this>;\n\tdelete(id: string | number | T): StorePromise<this>;\n\tquery(): Query<T>;\n}\n\ninterface StorePromise<T> extends Promise<T>, MemoryStore<T> { }\n\nexport interface OrderedQuery<T> extends Query<T> {\n\tthenBy(name: string, ascending?: boolean): this;\n}\n\nexport interface Query<T> extends Promise<T> {\n\twhere(condition: Conditional): this;\n\tfilter<U>(callback: (item: T, store: any) => boolean): this;\n\n\tselect<U>(selection: string[] | ((item: T, store: any) => U)): Query<U>;\n\tmap<U>(callback: (item: T, store: any) => U): Query<U>;\n\n\ttake(): this;\n\tskip(): this;\n\n\torderBy(name: string, ascending?: boolean): OrderedQuery<T>;\n\treverse(): this;\n\tsort(callback: (a: T, b: T) => number): this;\n\n\tgroupBy<U>(): Query<U>;\n\n\tdistinct(): this;\n\tunion(): this;\n\tintersect(): this;\n\texcept(): this;\n\n\ttoArray(): Promise<any[]>;\n\ttoList(): Promise<List<any>>;\n\tconstruct<T>(factory: ComposeFactory<T, any>): Promise<T[]>;\n\n\tfirst(): Promise<any>;\n\tfirstOrDefault(): Promise<any>;\n\telementAt(): Promise<any>;\n\n\tcount(): Promise<number>;\n\n\trange(): this;\n\trepeat(): this;\n\n\tany(): this;\n\tall(): this;\n\n\tcount(): Promise<number>;\n\tsum(): Promise<number>;\n\tmin(): Promise<number>;\n\tmax(): Promise<number>;\n\taverage(): Promise<number>;\n\taggregate(): Promise<number>;\n\n\tconcat(): this;\n\tjoin(): this;\n}\n\nexport interface ConditionalExpression extends Object { }\n\nexport interface Conditional {\n\texpression: ConditionalExpression;\n}\n\nexport interface ConditionalOperator extends Conditional {\n\tand(): Condition;\n\tor(): Condition;\n}\n\nexport interface ConditionComparison<T> {\n\tmatches(condition: RegExp): ConditionalOperator;\n\tequals(condition: T): ConditionalOperator;\n\tcontains(condition: T): ConditionalOperator;\n\tlessThan(condition: T): ConditionalOperator;\n\tgreaterThan(condition: T): ConditionalOperator;\n}\n\nexport interface Condition {\n\tproperty(property: string): ConditionComparison<string>;\n}\n"]}