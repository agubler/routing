{"version":3,"file":"createEvented.js","sourceRoot":"","sources":["createEvented.ts"],"names":[],"mappings":";;;;;;;;;IAAA,6BAAuB,2BAA2B,CAAC,CAAA;IAEnD,uBAAmB,kBAAkB,CAAC,CAAA;IACtC,wBAAoB,mBAAmB,CAAC,CAAA;IACxC,wBAAwC,sBAAsB,CAAC,CAAA;IAC/D,kCAA+C,qBAAqB,CAAC,CAAA;IAErE,8EAA8E;IAE9E;;OAEG;IACH,IAAM,YAAY,GAAG,IAAI,iBAAO,EAA8D,CAAC;IAiB/F;;;OAGG;IACH,sBAAsB,KAAU;QAC/B,MAAM,CAAC,OAAO,KAAK,KAAK,QAAQ,IAAI,IAAI,IAAI,KAAK,IAAI,OAAO,KAAK,CAAC,EAAE,KAAK,UAAU,CAAC;IACrF,CAAC;IAmCD,8BAA4D,QAA4B;QACvF,IAAI,MAAqB,CAAC;QAC1B,EAAE,CAAC,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC5B,MAAM,GAAG,QAAQ,CAAC;QACnB,CAAC;QACD,EAAE,CAAC,CAAC,OAAO,QAAQ,KAAK,QAAQ,CAAC,CAAC,CAAC;YAClC,MAAM,GAAG,qBAAM,CAAC,QAAQ,CAAC,CAAC;YAC1B,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACb,MAAM,IAAI,KAAK,CAAC,kCAA+B,QAAQ,OAAG,CAAC,CAAC;YAC7D,CAAC;QACF,CAAC;QACD,MAAM,CAAC,MAAM,GAAG,UAAU,KAAQ;YACjC,MAAM,CAAC,EAAE,CAAC,EAAE,OAAA,KAAK,EAAE,CAAC,CAAC;QACtB,CAAC,GAAS,QAAQ,CAAC;IACpB,CAAC;IAde,4BAAoB,uBAcnC,CAAA;IAED,IAAM,aAAa,GAAmB,iBAAO,CAAC;QAC5C,IAAI,YAAwB,KAAQ;YACnC,IAAM,MAAM,GAAG,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAClD,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACZ,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAC1B,CAAC;QACF,CAAC;QACD,EAAE,YAAC,IAAY,EAAE,QAAgC;YAChD,MAAM,CAAC,WAAE,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC;QACzE,CAAC;KACD,CAAC;SACD,KAAK,CAAC;QACN,KAAK,EAAE,2BAAiB;QACxB,UAAU,YAAC,QAAiB,EAAE,OAAuB;YACpD,iCAAiC;YACjC,YAAY,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YAE/B,EAAE,CAAC,CAAC,OAAO,IAAI,WAAW,IAAI,OAAO,CAAC,CAAC,CAAC;gBACvC,GAAG,CAAC,CAAC,IAAI,SAAS,IAAI,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC;oBACzC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,SAAS,EAAE,oBAAoB,CAAC,OAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC1F,CAAC;YACF,CAAC;QACF,CAAC;KACD,CAAC,CAAC;IAEJ;sBAAe,aAAa,CAAC","sourcesContent":["import { byType } from 'dojo-actions/createAction';\nimport { Handle, EventObject } from 'dojo-core/interfaces';\nimport { on } from 'dojo-core/aspect';\nimport WeakMap from 'dojo-core/WeakMap';\nimport compose, { ComposeFactory } from 'dojo-compose/compose';\nimport createDestroyable, { Destroyable } from './createDestroyable';\n\n/* TODO: consider a has flag for dojo-actions so it isn't a hard dependency */\n\n/**\n * A map of hashes of listeners for event types\n */\nconst listenersMap = new WeakMap<Evented, { [ type: string ]: EventedCallback<EventObject>}>();\n\n/**\n * Interface describes evented callbacks\n */\nexport interface EventedCallback<T extends EventObject> {\n\t/**\n\t * A callback that is called when the event fires\n\t * @param event The event object\n\t */\n\t(event: T): void;\n}\n\nexport interface Actionable<T extends EventObject> {\n\tdo(options?: { event: T; }): any;\n}\n\n/**\n * An Actionable callback type guard\n * @param value The value to guard against\n */\nfunction isActionable(value: any): value is Actionable<EventObject> {\n\treturn typeof value === 'object' && 'do' in value && typeof value.do === 'function';\n}\n\nexport type EventedListener<E extends EventObject> = EventedCallback<E> | Actionable<E> | string;\n\n/**\n * The options for the events\n */\nexport interface EventedOptions {\n\t/**\n\t * A map of listeners to attach on initialization\n\t */\n\tlisteners?: {\n\t\t[event: string]: EventedListener<EventObject>;\n\t};\n}\n\nexport interface Evented extends Destroyable {\n\t/**\n\t * Emit an event\n\t * @param event The event object to emit\n\t */\n\temit<T extends EventObject>(event: T): void;\n\n\t/* you can extend evented and use object literals to type the listener event */\n\n\t/**\n\t * Attach a listener to an event and return a handle that allows the removal of\n\t * the listener.\n\t * @param type The name of the event\n\t */\n\ton(type: string, listener: EventedListener<EventObject>): Handle;\n}\n\nexport interface EventedFactory extends ComposeFactory<Evented, EventedOptions> { }\n\nexport function resolveEventListener<E extends EventObject>(listener: EventedListener<E>): EventedCallback<E> {\n\tlet action: Actionable<E>;\n\tif (isActionable(listener)) {\n\t\taction = listener;\n\t}\n\tif (typeof listener === 'string') {\n\t\taction = byType(listener);\n\t\tif (!action) {\n\t\t\tthrow new Error(`Cannot resolve action type \"${listener}\"`);\n\t\t}\n\t}\n\treturn action ? function (event: E) {\n\t\taction.do({ event });\n\t} : <any> listener;\n}\n\nconst createEvented: EventedFactory = compose({\n\t\temit<T extends EventObject>(event: T): void {\n\t\t\tconst method = listenersMap.get(this)[event.type];\n\t\t\tif (method) {\n\t\t\t\tmethod.call(this, event);\n\t\t\t}\n\t\t},\n\t\ton(type: string, listener: EventedListener<Event>): Handle {\n\t\t\treturn on(listenersMap.get(this), type, resolveEventListener(listener));\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createDestroyable,\n\t\tinitialize(instance: Evented, options: EventedOptions) {\n\t\t\t/* Initialize the listener map */\n\t\t\tlistenersMap.set(instance, {});\n\n\t\t\tif (options && 'listeners' in options) {\n\t\t\t\tfor (let eventType in options.listeners) {\n\t\t\t\t\tinstance.own(instance.on(eventType, resolveEventListener(options.listeners[eventType])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\nexport default createEvented;\n"]}