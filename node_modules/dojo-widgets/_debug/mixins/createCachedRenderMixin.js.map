{"version":3,"file":"createCachedRenderMixin.js","sourceRoot":"","sources":["createCachedRenderMixin.ts"],"names":[],"mappings":"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","sourcesContent":["import { h, VNode, VNodeProperties } from 'maquette/maquette';\nimport { ComposeFactory } from 'dojo-compose/compose';\nimport { EventObject, Handle } from 'dojo-core/interfaces';\nimport { assign } from 'dojo-core/lang';\nimport Map from 'dojo-core/Map';\nimport WeakMap from 'dojo-core/WeakMap';\nimport { EventedListener } from './createEvented';\nimport { ParentMixin } from './createParentMixin';\nimport createRenderable, { Renderable } from './createRenderable';\nimport createStateful, { State, Stateful, StateChangeEvent, StatefulOptions } from './createStateful';\nimport createVNodeEvented, { VNodeEvented } from './createVNodeEvented';\n\nexport type StylesHash = { [style: string]: string; };\n\nexport interface CachedRenderState extends State {\n\t/**\n\t * The ID of this widget\n\t */\n\tid?: string;\n\n\t/**\n\t * Any label text for this widget\n\t */\n\tlabel?: string;\n\n\tclasses?: string[];\n\n\tstyles?: StylesHash;\n}\n\nexport interface CachedRenderParent extends ParentMixin<any> {\n\t/**\n\t * Invalidate the widget so that it will recalculate on its next render\n\t */\n\tinvalidate(): void;\n}\n\nexport interface CachedRenderMixin<S extends CachedRenderState> extends Stateful<S>, Renderable, VNodeEvented {\n\t/**\n\t * Returns the node attribute properties to be used by a render function\n\t * @param overrides Any optional overrides of properties\n\t */\n\tgetNodeAttributes(overrides?: VNodeProperties): VNodeProperties;\n\n\t/**\n\t * Returns any children VNodes that are part of the widget\n\t */\n\tgetChildrenNodes(): (VNode | string)[];\n\n\t/**\n\t * Invalidate the widget so that it will recalculate on its next render\n\t */\n\tinvalidate(): void;\n\n\t/**\n\t * An array of strings that represent classes to be set on the widget.  If classes are present in the state, getting and\n\t * setting classes is done on the state, otherwise they are shadowed on the instance.\n\t */\n\tclasses: string[];\n\n\tstyles: StylesHash;\n\n\tparent?: CachedRenderParent;\n\n\ton(type: 'statechange', listener: EventedListener<StateChangeEvent<S>>): Handle;\n\ton(type: string, listener: EventedListener<EventObject>): Handle;\n}\n\n/**\n * A map of dirty flags used when determining if the render function\n * should be called\n */\nconst dirtyMap = new Map<CachedRenderMixin<CachedRenderState>, boolean>();\n\n/**\n * A weak map of the rendered VNode to return when the widget is\n * not dirty.\n */\nconst renderCache = new WeakMap<CachedRenderMixin<CachedRenderState>, VNode>();\n\n/**\n * A weak map to shadown the classes for the widget\n */\nconst shadowClasses = new WeakMap<CachedRenderMixin<CachedRenderState>, string[]>();\n\nconst shadowStyles = new WeakMap<CachedRenderMixin<CachedRenderState>, StylesHash>();\n\nconst createCachedRenderMixin: ComposeFactory<CachedRenderMixin<CachedRenderState>, StatefulOptions<CachedRenderState>> = createStateful\n\t.mixin(createRenderable)\n\t.mixin({\n\t\tmixin: {\n\t\t\tgetNodeAttributes(overrides?: VNodeProperties): VNodeProperties {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\tconst props: VNodeProperties = cachedRender.state.id ? { id: cachedRender.state.id } : {};\n\t\t\t\tfor (let key in cachedRender.listeners) {\n\t\t\t\t\tprops[key] = cachedRender.listeners[key];\n\t\t\t\t}\n\t\t\t\tconst classes: { [index: string]: boolean; } = {};\n\t\t\t\tif (cachedRender.classes) {\n\t\t\t\t\tcachedRender.classes.forEach((c) => classes[c] = true);\n\t\t\t\t}\n\t\t\t\tprops.classes = classes;\n\t\t\t\tprops.styles = cachedRender.styles || {};\n\t\t\t\tprops.key = cachedRender;\n\t\t\t\tif (overrides) {\n\t\t\t\t\tassign(props, overrides);\n\t\t\t\t}\n\t\t\t\treturn props;\n\t\t\t},\n\n\t\t\tgetChildrenNodes(): (VNode | string)[] {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\treturn cachedRender.state.label ? [ cachedRender.state.label ] : undefined;\n\t\t\t},\n\n\t\t\trender(): VNode {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\tlet cached = renderCache.get(cachedRender);\n\t\t\t\tif (!dirtyMap.get(cachedRender) && cached) {\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcached = h(cachedRender.tagName, cachedRender.getNodeAttributes(), cachedRender.getChildrenNodes());\n\t\t\t\t\trenderCache.set(cachedRender, cached);\n\t\t\t\t\tdirtyMap.set(cachedRender, false);\n\t\t\t\t\treturn cached;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tinvalidate(): void {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\tif (dirtyMap.get(cachedRender)) { /* short circuit if already dirty */\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst parent = cachedRender.parent;\n\t\t\t\tdirtyMap.set(cachedRender, true);\n\t\t\t\trenderCache.delete(cachedRender); /* Allow GC to occur on renderCache */\n\t\t\t\tif (parent && parent.invalidate) {\n\t\t\t\t\tparent.invalidate();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tget classes(): string[] {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\treturn cachedRender.state.classes || shadowClasses.get(cachedRender);\n\t\t\t},\n\n\t\t\tset classes(value: string[]) {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\tif (cachedRender.state.classes) {\n\t\t\t\t\tcachedRender.setState({ classes: value });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tshadowClasses.set(cachedRender, value);\n\t\t\t\t\tcachedRender.invalidate();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tget styles(): StylesHash {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\treturn cachedRender.state.styles || shadowStyles.get(cachedRender);\n\t\t\t},\n\n\t\t\tset styles(value: StylesHash) {\n\t\t\t\tconst cachedRender: CachedRenderMixin<CachedRenderState> = this;\n\t\t\t\tif (cachedRender.state.styles) {\n\t\t\t\t\tcachedRender.setState({ styles: value });\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tshadowStyles.set(cachedRender, value);\n\t\t\t\t\tcachedRender.invalidate();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tparent: <CachedRenderParent> null\n\t\t},\n\t\tinitialize(instance) {\n\t\t\t/* at this point, casting instance as the final type blows up the type inference, so the only choice is to\n\t\t\t * cast as any */\n\t\t\tdirtyMap.set(<any> instance, true);\n\t\t\tshadowClasses.set(<any> instance, []);\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createVNodeEvented,\n\t\tinitialize(instance) {\n\t\t\tinstance.own(instance.on('statechange', () => { instance.invalidate(); } ));\n\t\t}\n\t});\n\nexport default createCachedRenderMixin;\n"]}