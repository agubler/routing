(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", 'dojo-core/WeakMap'], factory);
    }
})(function (require, exports) {
    "use strict";
    var WeakMap_1 = require('dojo-core/WeakMap');
    /**
     * Types of advice
     */
    (function (AdviceType) {
        AdviceType[AdviceType["Before"] = 0] = "Before";
        AdviceType[AdviceType["After"] = 1] = "After";
        AdviceType[AdviceType["Around"] = 2] = "Around";
    })(exports.AdviceType || (exports.AdviceType = {}));
    var AdviceType = exports.AdviceType;
    ;
    /**
     * A weak map of dispatchers used to apply the advice
     */
    var dispatchAdviceMap = new WeakMap_1.default();
    /**
     * Returns the dispatcher function for a given joinPoint (method/function)
     * @param joinPoint The function that is to be advised
     */
    function getDispatcher(joinPoint) {
        function dispatcher() {
            var _this = this;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var adviceMap = dispatchAdviceMap.get(dispatcher);
            if (adviceMap.before) {
                args = adviceMap.before.reduce(function (previousArgs, advice) {
                    var currentArgs = advice.apply(_this, previousArgs);
                    return currentArgs ? currentArgs : previousArgs;
                }, args);
            }
            var result = adviceMap.joinPoint.apply(this, args);
            if (adviceMap.after) {
                result = adviceMap.after.reduce(function (previousResult, advice) {
                    return advice.apply(_this, [previousResult].concat(args));
                }, result);
            }
            return result;
        }
        dispatchAdviceMap.set(dispatcher, {
            joinPoint: joinPoint
        });
        return dispatcher;
    }
    /**
     * Advise a join point (function) with supplied advice
     * @param joinPoint The function to be advised
     * @param type The type of advice to be applied
     * @param advice The advice to apply
     */
    function advise(joinPoint, type, advice) {
        var dispatcher = joinPoint;
        if (type === AdviceType.Around) {
            dispatcher = getDispatcher(advice.apply(this, [joinPoint]));
        }
        else {
            if (!dispatchAdviceMap.has(joinPoint)) {
                dispatcher = getDispatcher(joinPoint);
            }
            var adviceMap = dispatchAdviceMap.get(dispatcher);
            if (type === AdviceType.Before) {
                (adviceMap.before || (adviceMap.before = [])).unshift(advice);
            }
            else {
                (adviceMap.after || (adviceMap.after = [])).push(advice);
            }
        }
        return dispatcher;
    }
    /**
     * Apply advice *before* the supplied joinPoint (function)
     * @param joinPoint A function that should have advice applied to
     * @param advice The before advice
     */
    function before(joinPoint, advice) {
        return advise(joinPoint, AdviceType.Before, advice);
    }
    exports.before = before;
    /**
     * Apply advice *after* the supplied joinPoint (function)
     * @param joinPoint A function that should have advice applied to
     * @param advice The after advice
     */
    function after(joinPoint, advice) {
        return advise(joinPoint, AdviceType.After, advice);
    }
    exports.after = after;
    /**
     * Apply advice *around* the supplied joinPoint (function)
     * @param joinPoint A function that should have advice applied to
     * @param advice The around advice
     */
    function around(joinPoint, advice) {
        return advise(joinPoint, AdviceType.Around, advice);
    }
    exports.around = around;
});
//# sourceMappingURL=_debug/aspect.js.map